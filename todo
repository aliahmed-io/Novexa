# Novexa – Implementation TODO (From Prototype to Sellable Store)

This file is the **master implementation plan** to:

- Answer all evaluation questions and fix all identified problems.
- Implement missing features.
- Make the site realistically **sellable as a ready-to-launch store**.

For each area:
- **Problem** – what’s wrong / missing.
- **Solution** – what “done” looks like.
- **How to implement** – concrete steps.
- **Impacted code** – existing files to touch + new files to create.

---

## 0. Groundwork & Environment

### 0.1 Prisma schema & database state

- **Problem**
  - Schema has evolved, migrations were messy, and you had errors with `prisma migrate dev`.
  - Risk: schema in code and schema in Neon drift apart.

- **Solution**
  - Use `prisma db push` as the **source of truth** until you’re ready to regenerate migrations cleanly.

- **How to implement**
  1. Make sure `prisma/schema.prisma` reflects all desired models (including order shipping fields, TryOnSession, Meshy fields, etc.).
  2. Run `npx prisma db push` against Neon to sync schema.
  3. Run `npx prisma generate` to ensure client is up-to-date.
  4. Manually verify a few critical tables (User, Product, Order, Shipment) in Neon.

- **Impacted code**
  - `prisma/schema.prisma`
  - Any file that imports `@prisma/client` (compile-time impact only).

---

## 5. Security & Abuse Prevention

### 5.1 Rate limiting for critical endpoints

- **Problem**
  - `/api/assistant`, `/api/search`, `/api/checkout`, and contact/broadcast can be abused.

- **Solution**
  - Apply **rate limiting** per IP and/or per user for these endpoints.

- **How to implement**
  1. Implement a small rate-limiter using Upstash Redis or another store.
  2. Wrap critical routes with a helper that enforces limits.

- **Impacted code**
  - Existing:
    - `app/api/assistant/route.ts`
    - `app/api/search/route.ts`
    - `app/api/checkout/route.ts`
    - Contact form API and broadcast actions.
  - New:
    - `lib/rate-limit.ts` – shared helper.

### 5.2 Input validation & safer error messages

- **Problem**
  - Inputs are sometimes assumed valid; errors can leak implementation detail.

- **Solution**
  - Use a validation library (e.g. Zod) for all external inputs and map internal errors to friendly messages.

- **How to implement**
  1. Define Zod schemas for request payloads.
  2. Validate at the boundary (API route / server action).
  3. Catch and map errors to generic user-facing responses.

- **Impacted code**
  - All API routes and server actions that accept arbitrary input.

---

## 6. Legal & Compliance

### 6.1 Legal/policy pages

- **Problem**
  - A basic Privacy Policy page now exists, but there are still no Terms of Service, Returns & Refunds, or Shipping policy pages, and legal links are not yet wired into the footer.

- **Solution**
  - Add the remaining static legal pages and link all policies in the footer.

- **How to implement**
  1. Create static routes:
     - `/legal/terms`
     - `/legal/shipping`
     - `/legal/returns`
  2. Review and, if desired, consolidate the existing Privacy Policy route with a `/legal/privacy` alias or redirect.
  3. Use simple but professional copy (can be generated then reviewed).
  4. Update the storefront footer to link to Terms, Privacy, Shipping, and Returns pages.

- **Impacted code**
  - Existing:
    - `components/storefront/Footer.tsx` – add links.
  - New:
    - `app/legal/terms/page.tsx`, `privacy/page.tsx`, `shipping/page.tsx`, `returns/page.tsx`.

### 6.2 Cookie / tracking consent (future when analytics added)

- **Problem**
  - If analytics/tracking are added, you need consent banner.

- **Solution**
  - Implement a basic cookie consent banner with persistent preference.

- **Impacted code**
  - New banner component and small storage (cookie/localStorage) logic.

---

## 7. SEO & Marketing Polish

### 7.1 Metadata & OpenGraph

- **Problem**
  - Landing page has metadata, but product and key pages may lack rich, dynamic metadata.

- **Solution**
  - Ensure all major routes define `Metadata` with titles, descriptions, and OpenGraph/Twitter cards.

- **How to implement**
  1. Add `generateMetadata` to product pages to use product name, description, price, and main image.
  2. Define metadata for shop, categories, cart, and checkout.

- **Impacted code**
  - Existing:
    - `app/(landing page)/layout.tsx` – already has metadata.
    - `app/store/(storefront)/product/[id]/page.tsx` – add `generateMetadata`.
    - Other main pages under `app/store/(storefront)`.

### 7.2 Structured data (schema.org)

- **Problem**
  - No structured product data for search engines.

- **Solution**
  - Add JSON-LD `<script>` tag for Product schema on product pages.

- **How to implement**
  1. Generate JSON-LD object from product data.
  2. Inject via `<script type="application/ld+json">`.

- **Impacted code**
  - `app/store/(storefront)/product/[id]/page.tsx`.

---

## 8. Existing AI Features – Stabilize & Polish

### 8.1 AI assistant & AI search robustness

- **Problem**
  - Assistant/search require Gemini; failures and latency are not handled gracefully; no logging or limits.

- **Solution**
  - Add:
    - Proper error fallback messaging.
    - Usage logging.
    - Rate limiting (see Security).

- **How to implement**
  1. Wrap calls to Gemini in `try/catch` and return friendly error states.
  2. Log prompts, response times, and errors in a simple `AIInteractionLog` model (optional).

- **Impacted code**
  - Existing:
    - `app/api/assistant/route.ts`
    - `app/api/search/route.ts` and `filterProducts` helper.
  - New:
    - Optional `AIInteractionLog` model.

### 8.2 3D model generation (Meshy) UX

- **Problem**
  - Meshy-related fields exist, but there’s no full UX for progress tracking.

- **Solution**
  - Add a per-product 3D generation panel with status and progress.

- **How to implement**
  1. Implement async background polling or webhooks from Meshy to update `meshyStatus`, `meshyProgress`, `modelUrl`.
  2. Show status badges in product admin table and detail view.

- **Impacted code**
  - Existing:
    - Product admin pages and actions.
  - New:
    - Meshy webhook or polling job handler.

### 8.3 TryOnSession MVP

- **Problem**
  - `TryOnSession` exists in schema but no UI.

- **Solution**
  - MVP virtual try-on feature: user uploads photo + selects shoe; result images saved and displayed in a gallery.

- **How to implement**
  1. Add `/store/try-on` page:
     - Upload form (use existing UploadThing setup).
     - Shoe selection dropdown.
  2. Call external VTON API (Replicate/other) and store resulting image URL and metadata in `TryOnSession`.
  3. Show gallery of past TryOnSessions for logged-in user.

- **Impacted code**
  - Existing:
    - `prisma/schema.prisma` – `TryOnSession`.
  - New:
    - `app/store/(storefront)/try-on/page.tsx` and supporting components.

---

## 9. New AI-Native Flagship Features

### 9.1 AI Chief Operating Officer (COO) Mode

- **Problem**
  - Admin has powerful tools but no **guidance**; buyer wants AI that turns data into actions.

- **Solution**
  - AI COO dashboard card/page that:
    - Summarizes recent performance.
    - Suggests concrete actions (create discounts, launch campaigns, restock, etc.).
    - Optionally can **execute** some suggestions via server actions.

- **How to implement**
  1. **Data aggregation helper**
     - Write a server function that aggregates metrics: revenue, top products, cart abandonment, email performance.
  2. **Prompting**
     - Create a prompt template describing the business and supported actions.
     - Send metrics + prompt to Gemini.
  3. **Actions**
     - Map a subset of suggested actions to server actions (e.g. create discount, schedule email campaign) and let admin click “Apply this suggestion”.
  4. **UI**
     - New dashboard tab or card: “AI COO Mode”.

- **Impacted code**
  - Existing:
    - Admin dashboard pages and analytics helpers.
  - New:
    - `app/store/dashboard/ai-coo/page.tsx` or dedicated component.
    - `lib/ai/coo.ts` – prompt construction and Gemini call.

### 9.2 Auto-generated campaigns

- **Problem**
  - Broadcast email system exists but content creation is manual.

- **Solution**
  - AI-assisted campaign builder that drafts subject lines, body, and segmentation suggestions.

- **How to implement**
  1. Add “Generate with AI” button in campaign creation form.
  2. Send product and order context + rough theme (e.g. “summer sale”) to Gemini.
  3. Pre-fill subject and body fields; allow manual editing before send.

- **Impacted code**
  - Existing:
    - Admin broadcast email page.
  - New:
    - `lib/ai/campaigns.ts`.

### 9.3 AI flagging system (fraud & anomalies)

- **Problem**
  - No system to detect suspicious orders, reviews, or traffic patterns.

- **Solution**
  - Background job or scheduled task that scores activity and surfaces alerts in the dashboard.

- **How to implement**
  1. Define **Alert** model (type, severity, message, linked entity).
  2. Periodically scan orders and reviews for red flags (basic heuristics + optional AI).
  3. Display alerts in admin dashboard.

- **Impacted code**
  - New:
    - `Alert` model in Prisma.
    - `lib/ai/alerts.ts` or heuristic scanner.
    - Admin Alerts page or dashboard section.

---

## 10. Documentation & Handover (Sellability)

### 10.1 Technical README – ✅ v1 written

- **Problem**
  - README was previously minimal; buyer wouldn’t know how to set everything up.

- **Solution**
  - You now have a solid v1 README with:
    - Project overview and feature list.
    - Tech stack.
    - Basic Getting Started steps and deployment notes.
  - **Remaining polish (optional):**
    - Add per-service setup details (Stripe, Kinde, Resend, Shippo, Redis, Neon, Gemini, UploadThing).
    - Link to the env var cheat sheet from section 10.3.

- **Impacted code**
  - `README.md` – further expand with integration-specific setup and env var references if desired.

### 10.2 Non-technical operations guide

- **Problem**
  - Non-dev store owner won’t know how to operate the store (creating products, handling orders, returns, campaigns).

- **Solution**
  - A separate `OPERATIONS.md` or `docs/operations.md` explaining day-to-day tasks with screenshots/GIFs (optional).

- **Impacted code**
  - New docs file(s) under `docs/` or project root.

### 10.3 Env var & deployment cheat sheet

- **Problem**
  - Env vars are spread between `.env` and code; not obvious which are mandatory.

- **Solution**
  - Central `.env.example` and a section in README listing each required variable and its purpose.

- **Impacted code**
  - `.env.example` – add all required vars.
  - `README.md` – reference and explain.

---

## 11. Execution Order (High-Level)

1. Stabilize schema & DB (`prisma db push`).
2. Add legal pages & footer links.
3. Implement basic monitoring (Sentry) + minimal `/api/health`.
4. Add 2–3 key Playwright E2E tests around checkout/webhooks.
5. Tighten email/newsletter with subscriber model + unsubscribe. **(✅ implemented)**
6. Implement admin discounts management UI and wire it to the existing discount logic. **(✅ implemented)**
7. Add SEO metadata + product structured data.
8. Add integration health dashboard plus basic rate limiting and input validation. **(Integration health dashboard ✅ implemented; rate limiting & broader validation still TODO.)**
9. Add AI COO Mode as the first flagship AI feature.
10. Polish existing AI features (assistant/search, Meshy UX, TryOnSession MVP).
11. Write docs (technical README, operations guide, env cheat sheet).
12. Run a final QA & performance pass (cross-browser/device checks, Lighthouse, full staging verification).

## 12. Final QA, Performance & Launch

- **Problem**
  - Even after all features are implemented, there is no explicit checklist to ensure quality across browsers, devices, and real integrations before handing the project to a buyer.

- **Solution**
  - Add a lightweight **QA & launch** phase focused on manual testing and basic performance checks, and fix any critical issues discovered.

- **How to implement**
  1. Cross-browser/device sanity checks:
     - Test key flows (browse → product → add to bag → checkout → order history) on at least Chrome, Safari, Firefox, and a mobile browser.
     - Test admin flows (products, categories, orders, returns, emails, discounts) on desktop.
  2. Run Lighthouse (or equivalent) on landing, product page, cart, and checkout:
     - Address any obvious LCP/CLS issues (e.g. large images, layout shifts).
  3. Verify all external services on a staging environment:
     - Stripe test payments, Shippo rates/labels, Resend emails, Kinde auth, Redis, Neon, Gemini, UploadThing.
  4. Capture and fix any high-severity bugs found during this pass; defer low-severity UI nits to future work.

- **Impacted code**
  - Potentially any part of the app; this is a coordination step that may result in small fixes across the codebase rather than a single file.

Following this list will move the project from **7.5/10 codebase, 6/10 product** to something you can honestly sell as a **ready-to-launch AI-powered e‑commerce store**.

---

## 13. Optional Paid Add-Ons (Buyer Extensions)

These are **not required** for the core v1 that you sell, but can be offered as **paid add-on work** for buyers who want to invest more.

### 13.1 Multi-language support

- **Idea**
  - Allow the storefront and product content to be localized into multiple languages.

- **High-level approach**
  - Add a language switcher and language model/tables.
  - Make product/category copy translatable per language.

### 13.2 Multi-currency support

- **Idea**
  - Allow prices to be shown and charged in multiple currencies.

- **High-level approach**
  - Add a currency switcher and pricing strategy (per-currency prices or FX conversion).
  - Ensure Stripe configuration and price presentation stay consistent with the chosen model.
